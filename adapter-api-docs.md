# Загальне
- рахувати кількість запитів, які робить адаптер до апі
	- деякі провайдери мають обмежену кількість запитів

- **Легенда** - в яких умовах відбувається виконання 
- **Адаптер** - опис того, що прийде до адаптера, та того що ми отримаємо

- `id` - у більшості випадків - внутрішня id, та яку використовує постачальник
- `tecdocId` - наша id, пов'язана з тек доком
# Наявність товару у постачальників
## Легенда 
1. Вводимо артикул у пошукове поле
2. Шукаємо потрібну запчастину (по текдок) -> видаємо результат
3. Користувач обирає потрібну йому запчастину
	- маємо дані про запчастину = імя, опис і тд
	- відповідно нам не треба буде це від постачальників
	- від постачальників треба лише наявність на складах + ціна 
	- **чи є якась унікальна ідентифікація запчастини між всіма постачальниками?**
4. Шукаємо цю запчастину у всіх підключених постачальниках

## Адаптер
На моменті коли задіюємо адаптер у нас є:
- дані авторизації 
- дані про знайдену запчастину клієнтом 
### До адаптера йде:
- автентифікація користувача 
- дані про запчастину (ім'я, бренд, артикул, оригінальний код)
#### Приклад 
```json
{
	"access":{...},
	"data": {
		"name": "string", 
		"brand": "string",
		"article": "string",
		"barcode": "string" 
	}
}
```
- `access` - щось що потрібно для доступу, залежить від постачальника
	- всі варіанти доступу (які ми використали), треба описати в бд, та мати відповідний компонент на фронтенді 
- `data` - дані про запчастину, від нас, з текдок
### Від адаптера йде:
>внутрішнє - це те як збережено у постачальника, щоб можна було переконатися що це саме та запчастина
- внутрішня ід
- внутрішнє ім'я
- внутрішній опис
- внутрішній артикул
- ціна загальна 
	- **чи є потреба у різних валютах?**
- ціна для користувача 
	- **чи є потреба у різних валютах?**
- наявність на складах
#### Прилад
```json
[
	{
		"provider": "string",
		"id": "string (uuid)",
		"name": "string",
		"description": "string",
		"article": "string",
		"analog": "bool",
		"img": "string",
		"prices": [
			{
				"price": "number",
				"curencyName": "string"
			}
		],
		"customerPrices": {
			"prices": [
				{
					"price": "number",
					"curencyName": "string"
				}
			],
			"promos": [?...]
		},
		"rests": [
			{
				"type": "'in-stock' | 'in-waiting' | 'in-other'",
				"id": "string (uuid)", 
				"name": "string",
				"value": "number"
			}
		]
	}
]
```
- `provider` - що за провайдер, щось що буде його ідентифікувати у нашій системі 
- `analog` - omega дає ще аналоги при пошуку товару. якщо *true* - це аналог, *false* - оригінал
- `customerPrices` - ціни, специфічні для користувача
	- `promos` - знижки, є в bm 
- `rests` - наявність 
	- `rests.type` - тип наявності (в bm це поділено на окремі поля) 
		- in-stock - на складі 
		- in-waiting - очікуєтья 
		- in-other - хз що це

### Помилки
- стандартні як у http statuses   
# Кошик 
- у постачальника може бути декілька кошиків в одного користувача
- ? - певно не треба - якось відслідковувати і в нашій системі (обєднувати кошики між постачальниками) 
## Легенда 
### 1 -  додати товар у кошик 
1. Клієнт знайшов потрібну запчастину у потрібного постачальника 
2. Клікнув - додати у кошик
### 2 - перегляд кошика
1. Клієнт зайшов на кошик
2. Може:
	- переглянути всі кошики у всіх підключених постачальників
	- видалити товар з кошика
	- редагувати кількість товару в кошику  (?)
## Адаптер 

### GET - отримати дані про кошик
отримати товари, які користувач додав до кошика провайдера
bm - дає дані про запчастину 
omega - дає короткі дані про запчастину

omega - має лише одну корзину, прив'язано до користувача
bm - може мати декілька => для прощення треба зберігати ід корзини, і робити вигляда що там можлива лише одна
#### До адаптера
- дані авторизації (ключі доступу)
- ід корзини  (не завжди)
##### Приклад 
```json
{
	"access": {...},
	"cardId": "?number",
}
```
#### Від адаптера
- дані про корзину 
- дані про запчастину, яка там 
	- внутрішнє ід
	- (?) наскільки хороша ідея, кидати ще запит щоб отримати текдок (наша табличка) ід тут -> звідси можна буде добути всі інші дані 
	- імя 
	- бренд
	- кількість
	- ціна 
	- картинка
- загальна вартість 
**Наскільки багато даних треба щоб відображалося у корзині про запчастину?**
##### Приклад 
```json
{
	"provider": "string",
	"card": {
		"id": "string",
		"total": "number",
		"parts": [
			{
				"id": "string",
				"tecdocId": "?string",
				"name": "string",
				"?brand": "?string",
				"quantity": "number",
				"total": "number",
				"?img": "?string"
			}
		]
	}
}
```
- `cart.parts.total`, `cart.total` - загальна вартість, яка назбиралася для запчастини
	- **Треба ще валюта?** 
#### Помилки


### POST / PUT - додати / редагувати товар 
якщо у провайдера ще нема кошика -> створити його
клієнт обрав запчастину, та обрав постачальника - тикнув додати до кошика
ми маємо: дані про запчастину, дані про провайдера
даних про кошик може не бути (вони можуть бути і не потрібні)
#### До адаптера
- дані авторизації 
- дані про кошик
	- його ід
- дані про запчастину
	- внутрішнє ід
	- ? текдок ід
	- кількість
		-  **є щось, що не вимірюється в штуках?**
		- якщо кількість зменшується до 0 - видалити позицію з кошика (якщо це не робиться автоматично)
		- якщо загальна кількість всіх товарів зменшується до 0 - видалити кошик (якщо це не робиться автоматично)
##### Приклад 
```json
{
	"access": {...},
	"cardId": "string",
	"part": {
		"id": "string",
		"tecdocId": "string",
		"quantity": "number"
	}
}
```
#### Від адаптера
повідомлення про успіх / невдачу
##### Приклад 
```json
{
	"succsess": "bool",
	"message": "string",
	"cardId": "string"
}
```
- `cardId` - якщо було створено новий кошик, необхідно знайти його ід, для подальшої взаємодії
#### Помилки


### DELETE - очищення / видалення кошика
очистити кошик
#### До адаптера
- дані авторизації
- дані про кошик
##### Приклад
```json
{
	"access": {...},
	"cartId": "string"
}
```

#### Від адаптера
повідомлення про успіх / невдачу
##### Приклад 
```json
{
	"succsess": "bool",
	"message": "string",
	"cardId": "string"
}
```
#### Помилки

